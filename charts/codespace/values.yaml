# =============================================================================
# GLOBAL CONFIGURATION
# =============================================================================
nameOverride: ""
fullnameOverride: ""

# Global labels applied to ALL resources (including pods)
commonLabels: {}
  # environment: production
  # team: platform
  # cost-center: engineering

# Global annotations applied to ALL resources (including pods)
commonAnnotations: {}
  # company.com/owner: platform-team
  # company.com/project: codespace-operator

# Pod-specific labels (applied to ALL pods in addition to common labels)
podLabels: {}
  # sidecar.istio.io/inject: "true"
  # network-policy: enabled

# Pod-specific annotations (applied to ALL pods in addition to common annotations)
podAnnotations: {}
  # prometheus.io/scrape: "true"
  # fluentd/parser: json

# =============================================================================
# OPERATOR CONFIGURATION
# =============================================================================
operator:
  enabled: true
  replicaCount: 1

  # Component-specific labels (merged with global labels)
  labels: {}
    # tier: control-plane

  # Component-specific annotations (merged with global annotations)
  annotations: {}
    # operator-specific annotations

  # Pod-specific labels for operator (merged with global pod labels)
  podLabels: {}
    # component: session-controller

  # Pod-specific annotations for operator (merged with global pod annotations)
  podAnnotations: {}
    # scheduler.alpha.kubernetes.io/preferred-durations: '1m'

  image:
    repository: ghcr.io/codespace-operator/codespace-operator
    tag: ""
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    name: ""

  rbac:
    create: true

  webhook:
    enabled: false
    certPath: ""
    certName: tls.crt
    certKey: tls.key

  metrics:
    enabled: true
    secure: true
    bindAddress: :8443
    service:
      type: ClusterIP
      name: ""
      # Service-specific annotations (merged with component annotations)
      annotations: {}
        # prometheus.io/scrape: "true"
        # prometheus.io/port: "8443"
      port: 8443
      targetPort: 8443
    serviceMonitor:
      enabled: false
      namespace: ""
      interval: 30s
      scrapeTimeout: 10s
      labels: {}

  ingressClass:
    enabled: false
    name: codespace-operator
    controller: k8s.io/ingress-controller/codespace-operator

  enableHTTP2: false
  extraArgs: []

  resources:
    limits: {}
    requests:
      cpu: 100m
      memory: 128Mi

  securityContext: {}
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true

  nodeSelector: {}
  tolerations: []
  affinity: {}

# =============================================================================
# SERVER CONFIGURATION
# =============================================================================
server:
  enabled: true
  clusterScope: false
  logLevel: info

  # Component-specific labels (merged with global labels)
  labels: {}
    # tier: frontend

  # Component-specific annotations (merged with global annotations)
  annotations: {}
    # server-specific annotations

  # Pod-specific labels for server (merged with global pod labels)
  podLabels: {}
    # component: web-console

  # Pod-specific annotations for server (merged with global pod annotations)
  podAnnotations: {}
    # config.linkerd.io/proxy-memory-limit: 128Mi

  image:
    repository: ghcr.io/codespace-operator/codespace-server
    tag: ""
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    name: ""
    rbac:
      create: true

  # Use operator's service account instead of creating a separate one
  useManagerServiceAccount: false

  # =============================================================================
  # AUTHENTICATION CONFIGURATION
  # =============================================================================
  auth:
    file: ""           # if set, pod points to this rendered file, the config below defaults to creating /etc/codespace-operator/auth/auth.yaml
    manager:
      auth_path: /auth
      auth_logout_path: /auth/logout
      jwt_secret: ""
      session_cookie_name: CODESPACE_SESSION
      session_ttl: 60m
      same_site: lax               # lax | strict | none
      absolute_session_max: 24h
      allow_token_param: false

    providers:
      local:
        enabled: true
        users_path: /etc/codespace-operator/local-users.yaml
        bootstrap:
          allowed: false
          user: ""
          password: ""
        # This value is not canonical to auth.yaml!
        localUsers:
          users:
            - username: alice
              email: alice@codespace.test
              passwordHash: $2y$12$ZvPoFzmBDe3mnV2AoU5dZeO/AqZogc2fsyfg3nfm14Djg6p3qbp9K
      oidc:
        enabled: false
        issuer_url: ""
        client_id: ""
        client_secret: ""
        redirect_url: ""
        scopes: [openid, profile, email]
        insecure_skip_verify: false

      ldap:
        enabled: true
        url: ldap://openldap.ldap.svc.cluster.local:389
        start_tls: false
        insecure_skip_verify: true
        bind_dn: cn=admin,dc=codespace,dc=test
        bind_password: ""

        user:
          base_dn: ou=people,dc=codespace,dc=test
          filter: (|(uid={username})(mail={username}))
          dn_template: ""
          attrs:
            username: uid
            email: mail
            display_name: cn
          to_lower_username: true

        group:
          base_dn: ou=groups,dc=codespace,dc=test
          # NOTE: new contract requires {userDN}, not {dn}
          filter: (member={userDN})
          attr: cn

        roles:
          mapping:
            "codespace-operator:admin":  ["admin"]
            "codespace-operator:editor": ["editor"]
            "codespace-operator:viewer": ["viewer"]
          default: ["viewer"]


  # =============================================================================
  # NETWORK AND ROUTING
  # =============================================================================
  service:
    type: ClusterIP
    name: ""
    # Service-specific annotations (merged with component annotations)
    annotations: {}
      # service.beta.kubernetes.io/aws-load-balancer-type: nlb
    port: 8443
    targetPort: 8443

  ingress:
    enabled: false
    className: ""
    # Ingress-specific annotations
    annotations: {}
      # nginx.ingress.kubernetes.io/rewrite-target: /
      # cert-manager.io/cluster-issuer: letsencrypt-prod
    hosts:
      - host: console.codespace.test
        path: /
    tls: []

  # OpenShift route (alternative to ingress)
  route:
    enabled: false
    annotations: {}
    tls:
      termination: edge

  # Network security
  networkPolicy:
    enabled: true
    allowIngressFromSameNamespace: true
    egressToKubeAPIServer: true

  # =============================================================================
  # APPLICATION CONFIGURATION
  # =============================================================================
  env:
    allowOrigin: "*"  # Set to specific domain in production

  probes:
    readinessPath: /readyz
    livenessPath: /healthz

  resources:
    requests:
      cpu: 50m
      memory: 64Mi
    limits:
      cpu: 500m
      memory: 256Mi

  securityContext:
    runAsUser: 1001
    runAsNonRoot: true
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    capabilities:
      drop: [ALL]

  nodeSelector: {}
  tolerations: []
  affinity: {}

  # =============================================================================
  # RBAC CONFIGURATION (Casbin-based authorization)
  # =============================================================================
  rbac:
    # ConfigMap name for RBAC files (auto-generated if empty)
    configMapName: ""
    
    # Casbin model configuration
    model: |
      [request_definition]
      r = sub, obj, act, dom

      [policy_definition]
      p = sub, obj, act, dom, eft

      [role_definition]
      g = _, _

      [policy_effect]
      e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

      [matchers]
      m = (g(r.sub, p.sub) || r.sub == p.sub) && (p.obj == "*"  || r.obj == p.obj) && (p.act == "*"  || regexMatch(r.act, p.act)) && (p.dom == "*"  || keyMatch2(r.dom, p.dom))

    # Casbin policy rules
    policy: |
      # Role inheritance - Map external OIDC roles to internal roles
      g, codespace-operator:admin, admin
      g, codespace-operator:editor, editor  
      g, codespace-operator:viewer, viewer

      # Example for a single targeted user from an IdP
      # IssuerID derived from: https://idp.example.com/abcd/efgh
      # -> idp.example.com~abcd~efgh
      # p, oidc:idp.example.com~abcd~efgh:8f9a2c...., session, *, team-alpha, allow

      # Admin permissions (full access everywhere)
      p, admin, *, *, *, allow

      # p, admin, session, *, *, allow
      # p, admin, namespaces, *, *, allow

      # Editor permissions (CRUD sessions)
      p, editor, session, get, *, allow
      p, editor, session, list, *, allow
      p, editor, session, watch, *, allow
      p, editor, session, create, *, allow
      p, editor, session, update, *, allow
      p, editor, session, delete, *, allow
      p, editor, session, scale, *, allow

      # Viewer permissions (read-only)
      p, viewer, session, get, *, allow
      p, viewer, session, list, *, allow  
      p, viewer, session, watch, *, allow

      # Specific user permissions (examples)
      p, local:admin, *, *, *, allow
      p, local:alice, session, *, *, allow
      p, local:bob, session, *, default, allow

      # Environment-specific restrictions (examples)
      p, developer, session, get, dev-*, allow
      p, developer, session, list, dev-*, allow
      p, developer, session, create, dev-*, allow
      p, developer, session, update, dev-*, allow
      p, developer, session, delete, dev-*, deny

      # Deny policies override allows
      p, editor, session, delete, prod-*, deny